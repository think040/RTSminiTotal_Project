#include "../../../Utility/02_CShader/UtilityCS.hlsl"

#pragma kernel CS_PVF
#pragma kernel CS_OVF

#pragma kernel CS_PVF_Vertex
#pragma kernel CS_OVF_Vertex
#pragma kernel CS_Sphere_Vertex

#pragma kernel CS_PVF_Cull_Sphere
#pragma kernel CS_OVF_Cull_Sphere

#pragma kernel CS_Sphere_Center;

#define PvfNum 1
#define OvfNum 4

#define SpUnum 24
#define SpVnum 25  // 12 * 2 + 1 = 25

struct Info_VF
{
    float4 fi;
    float3 pos;
    float4 rot;
};


StructuredBuffer<Info_VF> info_pvf_Buffer;
StructuredBuffer<Info_VF> info_ovf_Buffer;

RWStructuredBuffer<float4> plane_pvf_Buffer;
RWStructuredBuffer<float4> plane_ovf_Buffer;

groupshared float3x3 R;
groupshared float4x2 planePvf[PvfNum][6];


[numthreads(1, PvfNum, 6)]
void CS_PVF (uint3 dtid : SV_DispatchThreadID, uint3 gid : SV_GroupID, uint3 gtid : SV_GroupThreadID, uint gidx : SV_GroupIndex)
{
    Info_VF vf = info_pvf_Buffer[gid.x * PvfNum + gtid.y];
    
    float4 fi = vf.fi;
    float3 pos = vf.pos;
    float4 rot = vf.rot;
    
    float fov = fi.x;
    float aspect = fi.y;
    float near = fi.z;
    float far = fi.w;       
    
    int i = 0;    
    if(gtid.z == 0)
    {
        R = Quaternion::toMat(rot);
        float3 dirZ = R.v3c2;
                
        float tany = tan(radians(0.5f * fov));
        float tanx = aspect * tany;
        
        planePvf[gtid.y][0].v3c0 = float3(+1.0f, +0.0f, -tanx);
        planePvf[gtid.y][1].v3c0 = float3(-1.0f, +0.0f, -tanx);
        planePvf[gtid.y][2].v3c0 = float3(+0.0f, +1.0f, -tany);
        planePvf[gtid.y][3].v3c0 = float3(+0.0f, -1.0f, -tany);
        planePvf[gtid.y][4].v3c0 = float3(+0.0f, +0.0f, +1.0f);
        planePvf[gtid.y][5].v3c0 = float3(+0.0f, +0.0f, -1.0f);           
        
        planePvf[gtid.y][0].v3c1 = f3zero;
        planePvf[gtid.y][1].v3c1 = f3zero;
        planePvf[gtid.y][2].v3c1 = f3zero;
        planePvf[gtid.y][3].v3c1 = f3zero;
        planePvf[gtid.y][4].v3c1 = float3(0.0f, 0.0f, far);
        planePvf[gtid.y][5].v3c1 = float3(0.0f, 0.0f, near);
    }
    
    GroupMemoryBarrierWithGroupSync();
    
    {
        float4 p;
        p.xyz = mul(R, normalize(planePvf[gtid.y][gtid.z].v3c0));
        //p.w = -mul(p.xyz, pos + R.v3c2 * planePvf[gtid.y][gtid.z].v3c1.z);
        p.w = -dot(p.xyz, pos + R.v3c2 * planePvf[gtid.y][gtid.z].v3c1.z);
                       
        planePvf[gtid.y][gtid.z].v4c0 = p;
    }
    
    GroupMemoryBarrierWithGroupSync();   
    
    {
        plane_pvf_Buffer[gid.x * PvfNum * 6 + gtid.y * 6 + gtid.z] = planePvf[gtid.y][gtid.z].v4c0;
      //plane_pvf_Buffer[gid.x * PvfNum * 6 + gtid.y * 6 + gtid.z] = float4(1.0f, 1.0f, 1.0f, 1.0f);
      //plane_pvf_Buffer[gid.x * PvfNum * 6 + gtid.y * 6 + gtid.z] = float4(pos, 1.0f);
    }        
        
}

groupshared float4x2 planeOvf[OvfNum][6];


[numthreads(1, OvfNum, 6)]
void CS_OVF(uint3 dtid : SV_DispatchThreadID, uint3 gid : SV_GroupID, uint3 gtid : SV_GroupThreadID, uint gidx : SV_GroupIndex)
{
    Info_VF vf = info_ovf_Buffer[gid.x * OvfNum + gtid.y];    
    
    float4 fi = vf.fi;
    float3 pos = vf.pos;
    float4 rot = vf.rot;
    
    float hv = fi.x;
    float aspect = fi.y;
    float near = fi.z;
    float far = fi.w;
    
    int i = 0;
    
    if(gidx == 0)
    {
        R = Quaternion::toMat(rot);
    }
    
    GroupMemoryBarrierWithGroupSync();
    
    if (gtid.z == 0)
    {                          
        float nx = hv * aspect;
        float ny = hv;
        float nz = (far - near) * 0.5f;
        
        planeOvf[gtid.y][0].v3c0 = float3(+1.0f, +0.0f, +0.0f);
        planeOvf[gtid.y][1].v3c0 = float3(-1.0f, +0.0f, +0.0f);
        planeOvf[gtid.y][2].v3c0 = float3(+0.0f, +1.0f, +0.0f);
        planeOvf[gtid.y][3].v3c0 = float3(+0.0f, -1.0f, +0.0f);
        planeOvf[gtid.y][4].v3c0 = float3(+0.0f, +0.0f, +1.0f);
        planeOvf[gtid.y][5].v3c0 = float3(+0.0f, +0.0f, -1.0f);                               
        
        planeOvf[gtid.y][0].v3c1 = float3(+nx, 0.0f, 0.0f);
        planeOvf[gtid.y][1].v3c1 = float3(-nx, 0.0f, 0.0f);
        planeOvf[gtid.y][2].v3c1 = float3(0.0f, +ny, 0.0f);
        planeOvf[gtid.y][3].v3c1 = float3(0.0f, -ny, 0.0f);
        planeOvf[gtid.y][4].v3c1 = float3(0.0f, 0.0f, +nz);
        planeOvf[gtid.y][5].v3c1 = float3(0.0f, 0.0f, -nz);               
    }
   
    GroupMemoryBarrierWithGroupSync();
    
    {
        float4 p;
        p.xyz = mul(R, planeOvf[gtid.y][gtid.z].v3c0);
        //p.w = -mul(p.xyz,
        //    pos +
        //    R.v3c2 * (far + near) * 0.5f +
        //    mul(R, planeOvf[gtid.y][gtid.z].v3c1));
        p.w = -dot(p.xyz,
            pos +
            R.v3c2 * (far + near) * 0.5f +
            mul(R, planeOvf[gtid.y][gtid.z].v3c1));
                       
        planeOvf[gtid.y][gtid.z].v4c0 = p;
    }
    
    GroupMemoryBarrierWithGroupSync();
    
    {
        plane_ovf_Buffer[gid.x * OvfNum * 6 + gtid.y * 6 + gtid.z] = planeOvf[gtid.y][gtid.z].v4c0;
    }
        
}

struct Vertex
{
    float3 position;
    float3 normal;
};

StructuredBuffer<Vertex> vf_vertex_Buffer;

RWStructuredBuffer<Vertex> pvf_vertex_Buffer;
RWStructuredBuffer<Vertex> ovf_vertex_Buffer;

groupshared float4x4 vfMat;
groupshared float3 pvfNom[4];
groupshared Vertex vfVtx[24];

[numthreads(24, 1, 1)]
void CS_PVF_Vertex(uint3 dtid : SV_DispatchThreadID, uint3 gid : SV_GroupID, uint3 gtid : SV_GroupThreadID, uint gidx : SV_GroupIndex)
{
    Info_VF vf = info_pvf_Buffer[gid.x];
    Vertex vOut;    
    
    float4 fi = vf.fi;
    float3 pos = vf.pos;
    float4 rot = vf.rot;
    
    float fov = fi.x;
    float aspect = fi.y;
    float near = fi.z;
    float far = fi.w;
                
    int i = 0;
    if(gidx == 0)
    {
        float4x4 m = f4x4Zero;
        m._m11 = tan(radians(fov / 2.0f));
        m._m00 = aspect * m._m11;
        m._m22 = 0.0f;
        m._m23 = 1.0f;
        m._m32 = -(far - near) / (2 * far * near);
        m._m33 = +(far + near) / (2 * far * near);        
        
        pvfNom[0] = float3(+1.0f, +0.0f, -m._m00);
        pvfNom[1] = float3(-1.0f, +0.0f, -m._m00);
        pvfNom[2] = float3(+0.0f, +1.0f, -m._m11);
        pvfNom[3] = float3(+0.0f, -1.0f, -m._m11);
    
        R = Quaternion::toMat(rot);
        vfMat = m;
    }
               
    GroupMemoryBarrierWithGroupSync();
    
    {
        float4x4 m = vfMat;
        float3 p = vf_vertex_Buffer[gtid.x].position;
        float3 n = vf_vertex_Buffer[gtid.x].normal;
        
        float4 vec = float4(2.0f * p, 1.0f);
        vec = mul(m, vec);
        vec = (1.0f / vec.w) * vec;
        p = vec.xyz;
        
        float3 nr = pvfNom[0];
        float3 nl = pvfNom[1];
        float3 nu = pvfNom[2];
        float3 nd = pvfNom[3];
        
        if (dot(n, float3(+1.0f, +0.0f, +0.0f)) > 0.0f)
        {
            n = nr;
        }
        else if (dot(n, float3(-1.0f, +0.0f, +0.0f)) > 0.0f)
        {
            n = nl;
        }
        else if (dot(n, float3(+0.0f, +1.0f, +0.0f)) > 0.0f)
        {
            n = nu;
        }
        else if (dot(n, float3(+1.0f, -1.0f, +0.0f)) > 0.0f)
        {
            n = nd;
        }
        
        vOut.position = pos + mul(R, p);
        vOut.normal = mul(R, n);
        vfVtx[gtid.x] = vOut;
    }
    
    GroupMemoryBarrierWithGroupSync();
    
    pvf_vertex_Buffer[gid.x * 24 + gtid.x] = vfVtx[gtid.x];
                
}

[numthreads(24, 1, 1)]
void CS_OVF_Vertex(uint3 dtid : SV_DispatchThreadID, uint3 gid : SV_GroupID, uint3 gtid : SV_GroupThreadID, uint gidx : SV_GroupIndex)
{
    Info_VF vf = info_ovf_Buffer[gid.x];
    Vertex vOut;
    
    float4 fi = vf.fi;
    float3 pos = vf.pos;
    float4 rot = vf.rot;
    
    float hv = fi.x;
    float aspect = fi.y;
    float near = fi.z;
    float far = fi.w;
                
    //near = 0;
    int i = 0;
    if (gidx == 0)
    {
        float4x4 m = f4x4Zero;
        m._m00 = aspect * hv;
        m._m11 = hv;        
        m._m22 = (far - near) * 0.5f;       
        m._m23 = (far + near) * 0.5f;
        m._m33 = 1.0f;                       
    
        R = Quaternion::toMat(rot);
        vfMat = m;
    }
               
    GroupMemoryBarrierWithGroupSync();
    
    {
        float4x4 m = vfMat;
        float3 p = vf_vertex_Buffer[gtid.x].position;
        float3 n = vf_vertex_Buffer[gtid.x].normal;
        
        float4 vec = float4(2.0f * p, 1.0f);
        vec = mul(m, vec);       
        p = vec.xyz;               
        
        vOut.position = pos + mul(R, p);
        vOut.normal = mul(R, n);
        vfVtx[gtid.x] = vOut;
    }
    
    GroupMemoryBarrierWithGroupSync();
    
    ovf_vertex_Buffer[gid.x * 24 + gtid.x] = vfVtx[gtid.x];
}


StructuredBuffer<float4> sphere_In_Buffer;
StructuredBuffer<float4x4> sphere_trM_Buffer;
RWStructuredBuffer<float4> sphere_Out_Buffer;

[numthreads(64, 1, 1)] //
void CS_Sphere_Center(uint3 dtid : SV_DispatchThreadID, uint3 gid : SV_GroupID, uint3 gtid : SV_GroupThreadID, uint gidx : SV_GroupIndex)
{
    uint idx = gid.x * 64 + gtid.x;
    
    float4 spOut = sphere_In_Buffer[idx];
    float4x4 M = sphere_trM_Buffer[idx];
       
    float3 pos = M.v3c0;
    float4 rot = M.v4c1;
    float3 sca = M.v3c2;
    
    float3x3 R = Quaternion::toMat(rot);
    
    spOut.xyz = pos + mul(R, spOut.xyz);
    
    sphere_Out_Buffer[idx] = spOut;
}


StructuredBuffer<float4> sphere_Buffer;
StructuredBuffer<Vertex> sphere_vertex_In_Buffer;

RWStructuredBuffer<Vertex> sphere_vertex_Out_Buffer;


[numthreads(SpVnum, SpUnum, 1)]
void CS_Sphere_Vertex(uint3 dtid : SV_DispatchThreadID, uint3 gid : SV_GroupID, uint3 gtid : SV_GroupThreadID, uint gidx : SV_GroupIndex)
{           
    //float4 sp = sphere_Buffer[gid.x];
    float4 sp = sphere_Out_Buffer[gid.x];
    float3 pos = sp.xyz;
    float r = sp.w;
           
    Vertex vIn = sphere_vertex_In_Buffer[gtid.x * SpUnum + gtid.y];
    Vertex vOut;    
    
    vOut.position = pos + r * vIn.position;
    vOut.normal = vIn.normal;
    
    //vOut.position = float3(8.0f, 8.0f, 8.0f);
    //vOut.normal = float3(8.0f, 8.0f, 8.0f);
    
    sphere_vertex_Out_Buffer[gid.x * SpVnum * SpUnum + gtid.x * SpUnum + gtid.y] = vOut;    
}

int spCount;

RWTexture3D<float> cullResult_pvf_Texture;
RWTexture3D<float> cullResult_ovf_Texture;

groupshared int planeOut[8][6];
groupshared int vfIn[8];

[numthreads(8, 1, 6)] // gid = (96, 1, 1)
void CS_PVF_Cull_Sphere(uint3 dtid : SV_DispatchThreadID, uint3 gid : SV_GroupID, uint3 gtid : SV_GroupThreadID, uint gidx : SV_GroupIndex)
{
    //if (gid.x * 8 + gtid.x < spCount)
    {
        float4 pl = plane_pvf_Buffer[gid.y * 6 + gtid.z];
        //float4 sp = sphere_Buffer[gid.x * 8 + gtid.x];
        float4 sp = sphere_Out_Buffer[gid.x * 8 + gtid.x];
        
        {
            int isOut = 0;
            if (dot(pl.xyz, sp.xyz) + pl.w > sp.w)
            {
                isOut = 1;
            }
            planeOut[gtid.x][gtid.z] = isOut;
        }
      
        GroupMemoryBarrierWithGroupSync();
    
        int i = 0;
        if (gtid.z == 0)
        {
            int isIn = 1;
            for (i = 0; i < 6; i++)
            {
                if (planeOut[gtid.x][i] == 1)
                {
                    isIn = 0;
                    break;
                }
            }
        
            vfIn[gtid.x] = isIn;
        }

        GroupMemoryBarrierWithGroupSync();
            
        cullResult_pvf_Texture[uint3(gid.x * 8 + gtid.x, gid.y, gid.z)] = (float) vfIn[gtid.x];
        //cullResult_pvf_Texture[uint3(gid.x * 8 + gtid.x, gid.y, gid.z)] = (float) (gid.x * 8 + gtid.x);

    }        
}


[numthreads(8, 1, 6)] // gid = (96, 4, 1)
void CS_OVF_Cull_Sphere(uint3 dtid : SV_DispatchThreadID, uint3 gid : SV_GroupID, uint3 gtid : SV_GroupThreadID, uint gidx : SV_GroupIndex)
{
    //if(gid.x * 8 + gtid.x < spCount)
    {
        float4 pl = plane_ovf_Buffer[gid.y * 6 + gtid.z];
        //float4 sp = sphere_Buffer[gid.x * 8 + gtid.x];
        float4 sp = sphere_Out_Buffer[gid.x * 8 + gtid.x];
        
        {
            int isOut = 0;
            if (dot(pl.xyz, sp.xyz) + pl.w > sp.w)
            {
                isOut = 1;
            }
            planeOut[gtid.x][gtid.z] = isOut;
        }
        
        GroupMemoryBarrierWithGroupSync();
    
        int i = 0;
        if (gtid.z == 0)
        {
            int isIn = 1;
            for (i = 0; i < 6; i++)
            {
                if (planeOut[gtid.x][i] == 1)
                {
                    isIn = 0;
                    break;
                }
            }
        
            vfIn[gtid.x] = isIn;
        }

        GroupMemoryBarrierWithGroupSync();
    
        cullResult_ovf_Texture[uint3(gid.x * 8 + gtid.x, gid.y, gid.z)] = (float) vfIn[gtid.x];
    }        
}


